#!/usr/bin/env ruby

require 'rubygems'
require 'gruff'

$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../lib'))
require 'railsbench/gc_info'

# extract options

selection = []
title = "GC Data Graph"
files = []
names = []
labels = %w()
perf_data = []
graph_type = Gruff::StackedBar
graph_width = '1400x1050'
font_size = 10
ignored_object_types = %w(NODE STRING)
output_file = "graph.png"

ARGV.each do |arg|
  case arg
  when /^-width=(\d+)$/
    graph_width = $1.to_i
  when /^-geometry=(\d+x\d+)$/
    graph_width = $1
   when /^-title=(.*)$/
     title = $1 unless $1.strip.empty?
#   when /^-names=(.+)$/
#     names = $1.split(',')
  when /^-font_size=(\d+)$/
    font_size = $1.to_i
  when /^-ignore=(.*)$/
    ignored_object_types = $1.split(',').compact.map{|s|s.upcase}
  when /^-out=(.+)$/
    output_file = $1
  else
    files << File.open_or_die(arg)
    names[files.length-1] ||= File.basename(arg)
  end
end

files.length > 0 or die "usage: perf_plot_gc [options] file1 file2 ..."

object_types = %w(NODE STRING ARRAY HASH  SCOPE VARMAP CLASS ICLASS REGEXP FLOAT MATCH FILE DATA MODULE OBJECT)

gcis = []
files.each do |file|
  gcis << GCInfo.new(file)
  object_types = (object_types + gcis.last.object_types.to_a).uniq
  file.close
end

object_types = object_types.to_a
gc_count_max = gcis.map{|gci| gci.collections}.max
gc_max_processed = gcis.map{|gci| gci.processed_max}.max
gc_max_freed = gcis.map{|gci| gci.freed_max}.max
gc_max_live = gcis.map{|gci| gci.live_max}.max

g = graph_type.new(graph_width)

%w(#FF0000 #00FF00 #0000FF #D2FF77 #FF68C0 #D1FDFF #FFF0BD #15FFDC
).each do |color|
 g.add_color(color)
end

g.title = title
g.sort = false
g.legend_font_size = font_size
g.legend_box_size = font_size
g.marker_font_size = font_size
if ignored_object_types.empty?
  g.minimum_value = 0
  g.maximum_value = [gc_max_freed, gc_max_live, 400000].max
end
g.labels = Hash[* (0...gc_count_max).map{|i| [2*i, i.to_s]}.flatten ]
# puts g.labels.inspect
# puts object_types.inspect

object_types.each do |ot|
  next if ignored_object_types.include?(ot)
  data = []
  gc_count_max.times do |gc_index|
    for gci in gcis
      map_at_this_gc = gci.freed_objects[gc_index]
      data << ((map_at_this_gc && map_at_this_gc[ot]) || 0)
      map_at_this_gc = gci.live_objects[gc_index]
      data << ((map_at_this_gc && map_at_this_gc[ot]) || 0)
    end
  end
  # puts "#{ot}: #{data.inspect}"
  g.data(ot, data)
end

class Gruff::StackedBar < Gruff::Base
  alias_method :old_draw, :draw
  def draw
    @d = @d.stroke_antialias false
    old_draw
  end
end

g.write(output_file)


__END__

#    Copyright (C) 2005-2008  Stefan Kaes
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
