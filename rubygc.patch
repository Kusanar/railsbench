--- gc.c.orig	2005-12-16 05:58:51.000000000 +0100
+++ gc.c	2006-04-03 11:52:50.389302400 +0200
@@ -22,8 +22,16 @@
 #include <setjmp.h>
 #include <sys/types.h>
 
+#ifdef _WIN32
+#include <string.h>
+#else
+#include <strings.h>
+#endif
+
 #ifdef HAVE_SYS_TIME_H
 #include <sys/time.h>
+#elif defined(_WIN32)
+#include <time.h> 
 #endif
 
 #ifdef HAVE_SYS_RESOURCE_H
@@ -118,6 +126,7 @@
     if (malloc_increase > malloc_limit) {
 	garbage_collect();
     }
+
     RUBY_CRITICAL(mem = malloc(size));
     if (!mem) {
 	garbage_collect();
@@ -175,8 +184,17 @@
 	RUBY_CRITICAL(free(x));
 }
 
+#if HAVE_LONG_LONG
+#define GC_TIME_TYPE LONG_LONG
+#else
+#define GC_TIME_TYPE long
+#endif
+
 extern int ruby_in_compile;
 static int dont_gc;
+static int gc_statistics = 0;
+static GC_TIME_TYPE gc_time = 0;
+static int gc_collections = 0;
 static int during_gc;
 static int need_call_final = 0;
 static st_table *finalizer_table = 0;
@@ -225,6 +243,104 @@
     return old;
 }
 
+/*
+ *  call-seq:
+ *     GC.enable_stats    => true or false
+ *
+ *  Enables garbage collection statistics, returning <code>true</code> if garbage
+ *  collection statistics was already enabled.
+ *
+ *     GC.enable_stats   #=> false or true
+ *     GC.enable_stats   #=> true
+ *
+ */
+
+VALUE
+rb_gc_enable_stats()
+{
+    int old = gc_statistics;
+    gc_statistics = Qtrue;
+    return old;
+}
+
+/*
+ *  call-seq:
+ *     GC.disable_stats    => true or false
+ *
+ *  Disables garbage collection statistics, returning <code>true</code> if garbage
+ *  collection statistics was already disabled.
+ *
+ *     GC.disable_stats   #=> false or true
+ *     GC.disable_stats   #=> true
+ *
+ */
+
+VALUE
+rb_gc_disable_stats()
+{
+    int old = gc_statistics;
+    gc_statistics = Qfalse;
+    return old;
+}
+
+/*
+ *  call-seq:
+ *     GC.enable_stats    => nil
+ *
+ *  Clears garbage collection statistics, returning nil. This resets the number
+ *  of collections (GC.collections) and the time used (GC.time) to 0.
+ *
+ *     GC.clear_stats    #=> nil
+ *
+ */
+
+VALUE
+rb_gc_clear_stats()
+{
+    gc_collections = 0;
+    gc_time = 0;
+    return Qnil; 
+}
+
+/*
+ *  call-seq:
+ *     GC.collections    => Integer
+ *
+ *  Returns the number of garbage collections performed while GC statistics collection
+ *  was enabled.
+ *
+ *     GC.clear_stats    #=> 35
+ *
+ */
+
+VALUE
+rb_gc_collections()
+{
+    return INT2NUM(gc_collections);
+}
+
+/*
+ *  call-seq:
+ *     GC.time    => Integer
+ *
+ *  Returns the time spent during garbage collection while GC statistics collection
+ *  was enabled (in micro seconds).
+ *
+ *     GC.time    #=> 20000
+ *
+ */
+
+VALUE
+rb_gc_time()
+{
+#if HAVE_LONG_LONG
+    return LL2NUM(gc_time);
+#else
+    return LONG2NUM(gc_time);
+#endif
+}
+
+
 VALUE rb_mGC;
 
 static struct gc_list {
@@ -308,7 +424,7 @@
 static RVALUE *freelist = 0;
 static RVALUE *deferred_final_list = 0;
 
-#define HEAPS_INCREMENT 10
+static int heaps_increment = 10;
 static struct heaps_slot {
     RVALUE *slot;
     int limit;
@@ -316,13 +432,75 @@
 static int heaps_length = 0;
 static int heaps_used   = 0;
 
-#define HEAP_MIN_SLOTS 10000
-static int heap_slots = HEAP_MIN_SLOTS;
+static int heap_min_slots = 10000;
+static int heap_slots = 10000;
 
-#define FREE_MIN  4096
+static int heap_free_min = 4096;
+
+static long initial_malloc_limit = GC_MALLOC_LIMIT;
+
+static int verbose_gc_stats = Qfalse;
 
 static RVALUE *himem, *lomem;
 
+static void set_gc_parameters()
+{
+    char *gc_stats_ptr, *min_slots_ptr, *free_min_ptr, *heap_incr_ptr, *malloc_limit_ptr;
+    
+    gc_stats_ptr = getenv("RUBY_GC_STATS");
+    if (gc_stats_ptr != NULL) {
+	int gc_stats_i = atoi(gc_stats_ptr);
+	if (gc_stats_i > 0) {
+	    verbose_gc_stats = Qtrue;
+	}
+    }
+
+    min_slots_ptr = getenv("RUBY_HEAP_MIN_SLOTS");
+    if (min_slots_ptr != NULL) {
+	int min_slots_i = atoi(min_slots_ptr);
+        if (verbose_gc_stats) {
+	    fprintf(stderr, "RUBY_HEAP_MIN_SLOTS=%s\n", min_slots_ptr);
+        }
+	if (min_slots_i > 0) {
+	    heap_slots = min_slots_i;
+	    heap_min_slots = min_slots_i;
+	}
+    }
+
+    free_min_ptr = getenv("RUBY_HEAP_FREE_MIN");
+    if (free_min_ptr != NULL) {
+	int free_min_i = atoi(free_min_ptr);
+        if (verbose_gc_stats) {
+	    fprintf(stderr, "RUBY_HEAP_FREE_MIN=%s\n", free_min_ptr);
+	}
+	if (free_min_i > 0) {
+	    heap_free_min = free_min_i;
+	}
+    }
+
+    heap_incr_ptr = getenv("RUBY_HEAP_INCREMENT");
+    if (heap_incr_ptr != NULL) {
+	int heap_incr_i = atoi(heap_incr_ptr);
+        if (verbose_gc_stats) {
+	    fprintf(stderr, "RUBY_HEAP_INCREMENT=%s\n", heap_incr_ptr);
+	}
+	if (heap_incr_i > 0) {
+	    heaps_increment = heap_incr_i;
+	}
+    }
+
+    malloc_limit_ptr = getenv("RUBY_GC_MALLOC_LIMIT");
+    if (malloc_limit_ptr != NULL) {
+	int malloc_limit_i = atol(malloc_limit_ptr);
+        if (verbose_gc_stats) {
+	    fprintf(stderr, "RUBY_GC_MALLOC_LIMIT=%s\n", malloc_limit_ptr);
+	}
+	if (malloc_limit_i > 0) {
+	    initial_malloc_limit = malloc_limit_i;
+	}
+    }
+}
+
 static void
 add_heap()
 {
@@ -333,7 +511,7 @@
 	struct heaps_slot *p;
 	int length;
 
-	heaps_length += HEAPS_INCREMENT;
+	heaps_length += heaps_increment;
 	length = heaps_length*sizeof(struct heaps_slot);
 	RUBY_CRITICAL(
 	    if (heaps_used > 0) {
@@ -350,10 +528,10 @@
 	RUBY_CRITICAL(p = heaps[heaps_used].slot = (RVALUE*)malloc(sizeof(RVALUE)*heap_slots));
 	heaps[heaps_used].limit = heap_slots;
 	if (p == 0) {
-	    if (heap_slots == HEAP_MIN_SLOTS) {
+	    if (heap_slots == heap_min_slots) {
 		rb_memerror();
 	    }
-	    heap_slots = HEAP_MIN_SLOTS;
+	    heap_slots = heap_min_slots;
 	    continue;
 	}
 	break;
@@ -1031,6 +1209,39 @@
     }
 }
 
+static char* obj_type(int tp)
+{
+    switch (tp) {
+	case T_NIL    : return "NIL";   
+	case T_OBJECT : return "OBJECT";
+	case T_CLASS  : return "CLASS";
+	case T_ICLASS : return "ICLASS";
+	case T_MODULE : return "MODULE";
+	case T_FLOAT  : return "FLOAT";
+	case T_STRING : return "STRING";
+	case T_REGEXP : return "REGEXP";
+	case T_ARRAY  : return "ARRAY";
+	case T_FIXNUM : return "FIXNUM";
+	case T_HASH   : return "HASH";
+	case T_STRUCT : return "STRUCT";
+	case T_BIGNUM : return "BIGNUM";
+	case T_FILE   : return "FILE";
+	    
+	case T_TRUE   : return "TRUE";
+	case T_FALSE  : return "FALSE";
+	case T_DATA   : return "DATA";
+	case T_MATCH  : return "MATCH";
+	case T_SYMBOL : return "SYMBOL";
+	    
+	case T_BLKTAG : return "BLKTAG";
+	case T_UNDEF  : return "UNDEF";
+	case T_VARMAP : return "VARMAP";
+	case T_SCOPE  : return "SCOPE";
+	case T_NODE   : return "NODE";
+	default: return "____";
+    }
+}
+
 static void
 gc_sweep()
 {
@@ -1039,6 +1250,15 @@
     int i;
     unsigned long live = 0;
 
+    unsigned long really_freed = 0;
+    int free_counts[256];
+    int live_counts[256];
+    int do_gc_stats = gc_statistics & verbose_gc_stats;
+
+    if (do_gc_stats) {
+	for (i = 0 ; i< 256; i++) { free_counts[i] = live_counts[i] = 0; }
+    }
+
     if (ruby_in_compile && ruby_parser_stack_on_heap()) {
 	/* should not reclaim nodes during compilation
            if yacc's semantic stack is not allocated on machine stack */
@@ -1070,6 +1290,9 @@
 	    if (!(p->as.basic.flags & FL_MARK)) {
 		if (p->as.basic.flags) {
 		    obj_free((VALUE)p);
+		    if (do_gc_stats) {
+			really_freed++;
+		    }
 		}
 		if (need_call_final && FL_TEST(p, FL_FINALIZE)) {
 		    p->as.free.flags = FL_MARK; /* remain marked */
@@ -1077,6 +1300,12 @@
 		    final_list = p;
 		}
 		else {
+		    if (do_gc_stats) {
+			int obt = p->as.basic.flags & T_MASK;
+			if (obt) {
+			    free_counts[obt]++;
+			}
+		    }
 		    p->as.free.flags = 0;
 		    p->as.free.next = freelist;
 		    freelist = p;
@@ -1090,10 +1319,13 @@
 	    else {
 		RBASIC(p)->flags &= ~FL_MARK;
 		live++;
+		if (do_gc_stats) {
+		    live_counts[RANY((VALUE)p)->as.basic.flags & T_MASK]++;
+		}
 	    }
 	    p++;
 	}
-	if (n == heaps[i].limit && freed > FREE_MIN) {
+	if (n == heaps[i].limit && freed > heap_free_min) {
 	    RVALUE *pp;
 
 	    heaps[i].limit = 0;
@@ -1108,14 +1340,28 @@
     }
     if (malloc_increase > malloc_limit) {
 	malloc_limit += (malloc_increase - malloc_limit) * (double)live / (live + freed);
-	if (malloc_limit < GC_MALLOC_LIMIT) malloc_limit = GC_MALLOC_LIMIT;
+	if (malloc_limit < initial_malloc_limit) malloc_limit = initial_malloc_limit;
     }
     malloc_increase = 0;
-    if (freed < FREE_MIN) {
+    if (freed < heap_free_min) {
 	add_heap();
     }
     during_gc = 0;
 
+    if (do_gc_stats) {
+	fprintf(stderr, "objects processed: %.7d\n", live+freed);
+	fprintf(stderr, "live objects     : %.7d\n", live);
+	fprintf(stderr, "freelist objects : %.7d\n", freed - really_freed);
+	fprintf(stderr, "freed objects    : %.7d\n", really_freed);
+	for(i=0; i<256; i++) {
+	    if (free_counts[i]>0) {
+		fprintf(stderr,
+			"kept %.7d / freed %.7d objects of type %s\n",
+			live_counts[i], free_counts[i], obj_type(i));
+	    }
+	}
+    }
+
     /* clear finalization list */
     if (final_list) {
 	deferred_final_list = final_list;
@@ -1311,6 +1557,7 @@
     struct gc_list *list;
     struct FRAME * volatile frame; /* gcc 2.7.2.3 -O2 bug??  */
     jmp_buf save_regs_gc_mark;
+    struct timeval gctv1, gctv2;
     SET_STACK_END;
 
 #ifdef HAVE_NATIVETHREAD
@@ -1327,6 +1574,14 @@
     if (during_gc) return;
     during_gc++;
 
+    if (gc_statistics) {
+        gc_collections++;
+	gettimeofday(&gctv1, NULL);
+        if (verbose_gc_stats) {
+	    fprintf(stderr, "Garbage collection started\n");
+	}
+    }
+
     init_mark_stack();
 
     /* mark frame stack */
@@ -1409,6 +1664,17 @@
 	}
     }
     gc_sweep();
+
+    if (gc_statistics) {
+        GC_TIME_TYPE musecs_used;
+	gettimeofday(&gctv2, NULL);
+	musecs_used = ((GC_TIME_TYPE)(gctv2.tv_sec - gctv1.tv_sec) * 1000000) + (gctv2.tv_usec - gctv1.tv_usec);
+	gc_time += musecs_used;
+
+	if (verbose_gc_stats) {
+	    fprintf(stderr, "GC time: %d msec\n", musecs_used / 1000);
+	}
+    }
 }
 
 void
@@ -1522,6 +1788,7 @@
     if (!rb_gc_stack_start) {
 	Init_stack(0);
     }
+    set_gc_parameters();
     add_heap();
 }
 
@@ -1920,6 +2187,12 @@
     rb_define_singleton_method(rb_mGC, "disable", rb_gc_disable, 0);
     rb_define_method(rb_mGC, "garbage_collect", rb_gc_start, 0);
 
+    rb_define_singleton_method(rb_mGC, "enable_stats", rb_gc_enable_stats, 0);
+    rb_define_singleton_method(rb_mGC, "disable_stats", rb_gc_disable_stats, 0);
+    rb_define_singleton_method(rb_mGC, "clear_stats", rb_gc_clear_stats, 0);
+    rb_define_singleton_method(rb_mGC, "collections", rb_gc_collections, 0);
+    rb_define_singleton_method(rb_mGC, "time", rb_gc_time, 0);
+
     rb_mObSpace = rb_define_module("ObjectSpace");
     rb_define_module_function(rb_mObSpace, "each_object", os_each_obj, -1);
     rb_define_module_function(rb_mObSpace, "garbage_collect", rb_gc_start, 0);
